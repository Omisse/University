#include "functions.hpp"

namespace S2L1::Functions {
int find_max(std::vector<int> A, int n) {
  int out = 0x80000000;  // min int
  for (int i = 0; i < n; i++) {
    if (A[i] > out) {
      out = A[i];
    }
  }
  return out;
}

int F20_val(std::vector<int> A, int n) {
  //Инициализруем переменные-счётчики i,k,j;
  int i = 0, k = 0, j = 0;
  /*
  Движемся по массиву A от 0 до n-1 включительно, сравнивая между собой i-й (каждый раз новый) и k-й (эталонный) элементы
массива.
  */
  for (i = 1, k = 0; i < n; i++)
    //По результатам сравнения в переменной k получаем индекс первого наибольшего элемента массива A.
    if (A[i] > A[k]) k = i;
  // Инициализируем out значением k-го элемента сейчас, ведь далее он будет удалён.
  int out = A[k];
  //Наибольший (k-й) элемент убирается из массива, а все элементы правее него - однократно смещаются влево.
  for (j = k; j < n - 1; j++) A[j] = A[j + 1];
  /* 
  Уменьшаем длину на 1, поскольку один элемент был убран.
  (Впрочем, память-то под него никуда не делась...) 
  */
  n--;
  return out;
}

int F20_ref(std::vector<int>& A, int& n) {
  int i = 0, k = 0, j = 0;
  for (i = 1, k = 0; i < n; i++)
    if (A[i] > A[k]) k = i;
  int out = A[k];
  for (j = k; j < n - 1; j++) A[j] = A[j + 1];
  n--;
  return out;
}

//Для работы со значением по адресу, нам необходимо разименовать указатель (ранее A[i], теперь (*A)[i]).
int F20_pointer(std::vector<int>* A, int* n) {
  int i = 0, k = 0, j = 0;
  for (i = 1, k = 0; i < *n; i++)
    if ((*A)[i] > (*A)[k]) k = i;
  int out = (*A)[k];
  for (j = k; j < (*n) - 1; j++) (*A)[j] = (*A)[j + 1];
  (*n)--;
  return out;
}

int F29_val(std::vector<int> A, int n) {
  //Инициализируем v максимальным значением среди элементов массива А.
  int v = find_max(A, n);
  int i = 0;
  //Инициализируем i, далее движемся по массиву A от 0 до n-1 включительно
  for (i = 0; i < n; i++)
    /*
    В случае, если i-й элемент массива не делится нацело на v, уменьшаем v на 1 и
    начинаем заново
    */
    if (A[i] % v != 0) {
      v--;
      /*
      i = -1; ->
      после выполнится i++ из шапки цикла ->
      i==0 на следующей итерации.
      */
      i = -1;
    }
  return v;
}

int F29_ref(std::vector<int>& A, int& n) {
  int v = find_max(A, n);
  int i = 0;
  for (i = 0; i < n; i++)
    if (A[i] % v != 0) {
      v--;
      i = -1;
    }
  return v;
}

//Для работы со значением по адресу, нам необходимо разименовать указатель (ранее A[i], теперь (*A)[i]).
int F29_pointer(std::vector<int>* A, int* n) {
  int v = find_max(*A, *n);
  int i = 0;
  for (i = 0; i < *n; i++)
    if ((*A)[i] % v != 0) {
      v--;
      i = -1;
    }
  return v;
}

int F32_val(std::vector<int> c, int n) {
  int s, i, k, j, b;
  //Инициализируем i, s, далее движемся по массиву c от 0 до n-1;
  for (s = 0, i = 0; i < n; i++) {
    /*
    Для каждого i инициализируем k,j, после чего заново
    проходим весь массив, сравнивая i-й и j-й элементы.
    */
    for (k = 0, j = 0; j < n; j++)
      if (c[i] == c[j]) k++;
    /*
    После прохождения, получаем k == количество вхождений i-го элемента в массив c
    Если данное количество больше эталонного (начиная с s == 0),
    то количество вхождений i-го элемента становится эталонным (s = k),
    а индекс элемента сохраняется в b.
    */
    if (k > s) s = k, b = i;
  }
  return b;
}

int F32_ref(std::vector<int>& c, int& n) {
  int s, i, k, j, b;
  for (s = 0, i = 0; i < n; i++) {
    for (k = 0, j = 0; j < n; j++)
      if (c[i] == c[j]) k++;
    if (k > s) s = k, b = i;
  }
  return b;
}

//Для работы со значением по адресу, нам необходимо разименовать указатель (ранее A[i], теперь (*A)[i]).
int F32_pointer(std::vector<int>* c, int* n) {
  int s, i, k, j, b;
  for (s = 0, i = 0; i < (*n); i++) {
    for (k = 0, j = 0; j < (*n); j++)
      if ((*c)[i] == (*c)[j]) k++;
    if (k > s) s = k, b = i;
  }
  return b;
}


int F50_val(std::vector<int> A) {
  int i, s, k;
  //Инициализируем i,s,k, далее движемся по массиву A от 0 до 9 включительно.
  for (i = 0, s = 0, k = 0; i < 10; i++) {
    /*
    Скажем, что k в рамках итерации - знак прошлого элемента массива.
    k = 0 если элемент был положительным,
    k = 1 в противном случае.
    */
    if (A[i] < 0)
      k = 1;
    else {
      /*
      Если прошлый элемент был отрицательным, а текущий - положителен,
      то увеличиваем счётчик (s) на 1.
      */
      if (k == 1) s++;
      k = 0;
    }
  }
  return s;
}

int F50_ref(std::vector<int>& A) {
  int i, s, k;
  for (i = 0, s = 0, k = 0; i < 10; i++) {
    if (A[i] < 0)
      k = 1;
    else {
      if (k == 1) s++;
      k = 0;
    }
  }
  return s;
}

//Для работы со значением по адресу, нам необходимо разименовать указатель (ранее A[i], теперь (*A)[i]).
int F50_pointer(std::vector<int>* A) {
  int i, s, k;
  for (i = 0, s = 0, k = 0; i < 10; i++) {
    if ((*A)[i] < 0)
      k = 1;
    else {
      if (k == 1) s++;
      k = 0;
    }
  }
  return s;
}

int F56_val(std::vector<int> A) {
  //Инициализируем i,s, движемся по массиву A от 1 до 9 включительно.
  int i, s = 0;
  for (i = 1, s = 0; i < 10; i++)
    /*
    Если среди элементов встречено чередование -,+ (как и в прошлой функции),
    увеличиваем счётчик на 1.
    */
    if (A[i] > 0 && A[i - 1] < 0) s++;
  return s;
}

int F56_ref(std::vector<int>& A) {
  int i, s = 0;
  for (i = 1, s = 0; i < 10; i++)
    if (A[i] > 0 && A[i - 1] < 0) s++;
  return s;
}

//Для работы со значением по адресу, нам необходимо разыменовать указатель (ранее A[i], теперь (*A)[i]).
int F56_pointer(std::vector<int>* A) {
  int i, s = 0;
  for (i = 1, s = 0; i < 10; i++)
    if ((*A)[i] > 0 && (*A)[i - 1] < 0) s++;
  return s;
}
}
