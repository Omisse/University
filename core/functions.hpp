#ifndef S2L1_FUNCTIONS_H
#define S2L1_FUNCTIONS_H

#include <vector>

namespace S2L1::Functions {
/*
Здесь и далее:
То, что мы привыкли понимать под "массивом" - в сущности, лишь указатель на его
первый элемент Для наглядности разницы в передаче по значению и по
ссылке/указателю будет использоваться std::vector - последовательный контейнер,
обладающий в наших условиях схожим синтаксисом, но являющийся структурой данных,
вследствие чего мы можем передать его значение, а не адрес в памяти.

В дальнейших комментариях к задаче под "массивом" будет подразумеваться
любая структура элементов одного типа, с последовательным доступом к ним.
*/

// Вспомогательная функция для поиска наибольшего элемента массива.
// Используется в функции 29 при инициализации v;
int find_max(std::vector<int> A, int n);

/*
Функция 20:
//Инициализируем две переменных i=1, k=0
//далее движемся по массиву A от 0 до n-1 включительно
//сравнивая между собой i-й (каждый раз новый) и k-й (эталонный) элементы
массива. for (i=1,k=0; i<n; i++) if (A[i]>A[k]) k=i; //По результатам сравнения
в переменной k получаем индекс первого наибольшего элемента массива A.
//Далее, наибольший элемент убирается из массива, а все элементы правее него -
однократно смещаются влево. for (j=k; j<n-1;j++) A[j]=A[j+1];
//Уменьшаем длину на 1, поскольку один элемент был убран. (Впрочем, память-то
под него никуда не делась...) n--;

Итог: функция однократно убирает наибольший элемент массива.
В случае, если таких элементов несколько, убран будет лишь элемент с наибольшим
индексом.

Стандартные решения:
    Переменная - максимум.
    Поиск - полный перебор
    Индексы как независимые перемещения в цикле.
    Предыдущий, текущий, следующий (в рамках следующего решения)
    Удаление с сохранением порядка
*/
int F20_val(std::vector<int> A, int n);
int F20_ref(std::vector<int>& A, int& n);
int F20_pointer(std::vector<int>* A, int* n);

/*
Функция 29:
//Инициализируем i, далее движемся по массиву A от 0 до n-1 включительно;
for (i=0; i<n; i++)
    //В случае, если i-й элемент массива не кратен v, уменьшаем v на 1 и
начинаем заново
    //i = -1; -> после выполнится i++ из шапки цикла -> i=0 на следующей
итерации. if (A[i] % v != 0) { v--; i=-1;
    }

Итог: функция предназначена для нахождения наибольшего общего делителя для
элементов массива. Предположим, что будет логично инициализировать v значением
наибольшего элемента массива.

Стандартные решения:
    Переменная - максимум(ведь ищем максимальное значение) - счётчик(ведь
уменьшем его на единицу с каждой реитерацией) Свойство всеобщности (алгоритмы из
cprog 2.4 модифицированы под реитерацию) Неравномерное движение (сразу прыгаем в
начало если первый найденный не соответствует условию)

*/
int F29_val(std::vector<int> A, int n);
int F29_ref(std::vector<int>& A, int& n);
int F29_pointer(std::vector<int>* A, int* n);

/*
Функция 32:
//Инициализируем i, s, далее движемся по массиву c от 0 до n-1;
for (s=0,i=0; i<n; i++) {
    //Для каждого i инициализируем k,j, после чего заново проходим весь массив,
сравнивая i-й и j-й элементы. for (k=0,j=0; j<n; j++) if (c[i]==c[j]) k++;
    //После прохождения, получаем k = количество вхождений i-го элемента в
массив c
    //Если данное количество больше эталонного (начиная с s = 0)
    //То количество вхождений i-го элемента становится эталонным
    //Индекс элемента сохраняется в b.
    if (k>s) s=k,b=i;
}

Итог: функция предназначена для нахождения индекса элемента с наибольшим
количеством вхождений в массив И/или количества вхождений этого элемента.

Стандартные решения:
    Переменная - счётчик
    Переменная - максимум
    Вложенные циклы
*/
int F32_val(std::vector<int> c, int n);
int F32_ref(std::vector<int>& c, int& n);
int F32_pointer(std::vector<int>* c, int* n);

/*
Функция 50:
//Инициализируем i,s,k, далее движемся по массиву A от 0 до 9 включительно.
//Скажем, что k в рамках итерации - знак прошлого элемента массива. k = 0 если
элемент был положительным, и = 1 в противном случае. for (i=0,s=0,k=0; i<10;
i++) if (A[i]<0) k=1; else {
        //Если прошлый элемент был отрицательным, а текущий - положителен, то
увеличиваем счётчик (s) на 1. if (k==1) s++; k=0;
    }

Итог: функция предназначена для подсчёта чередований -,+ в рамках первых 10
элементов массива. В случае, если массив состоит менее, чем из 10 элементов,
функция вызовет исключение с кодом ошибки 11 (SEGFAULT). Функционально -
абсолютно идентична F56.

Стандартные решения:
    Переменная - счётчик
    Переменная - признак
    Предыдущий, текущий, следующий (в варианте с флаговой переменной, но логика
в целом та же)

*/
int F50_val(std::vector<int> A);
int F50_ref(std::vector<int>& A);
int F50_pointer(std::vector<int>* A);

/*
Функция 56:
Инициализируем i,s, движемся по массиву A от 1 до 9 включительно.
Если среди элементов встречено чередование -,+ (как и в прошлой функции),
увеличиваем счётчик на 1. for (i=1,s=0; i<10; i++) if (A[i]>0 && A[i-1]<0) s++;

Итог: функция предназначена для подсчёта чередований -,+ в рамках первых 10
элементов массива. В случае, если массив состоит менее, чем из 10 элементов,
функция вызовет исключение с кодом ошибки 11 (SEGFAULT). Функционально -
абсолютно идентична F50.

Стандартные решения:
    Переменная - счётчик
    Предыдущий, текущий, следующий
*/
int F56_val(std::vector<int> A);
int F56_ref(std::vector<int>& A);
int F56_pointer(std::vector<int>* A);
}  // namespace S2L1::Functions

#endif