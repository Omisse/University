#ifndef S2L1_FUNCTIONS_H
#define S2L1_FUNCTIONS_H

#include <vector>

namespace S2L1::Functions {
/*
Здесь и далее:
То, что мы привыкли понимать под "массивом" - в сущности, лишь указатель на его
первый элемент. Для наглядности разницы в передаче по значению и по
ссылке/указателю будет использоваться std::vector - последовательный контейнер,
обладающий в наших условиях схожим синтаксисом, но являющийся структурой данных,
вследствие чего мы можем передать его значение, а не адрес в памяти.

В дальнейших комментариях к задаче под "массивом" будет подразумеваться
любая структура элементов одного типа, с последовательным доступом к ним.
*/

// Вспомогательная функция для поиска наибольшего элемента массива.
// Используется в функции 29 при инициализации v;
int find_max(std::vector<int> A, int n);

/*
Функция 20:
Функция однократно убирает наибольший элемент массива.
В случае, если таких элементов несколько, убран будет лишь элемент с наибольшим
индексом.

Стандартные решения:
    Переменная - максимум.
    Поиск - полный перебор
    Индексы как независимые перемещения в цикле.
    Предыдущий, текущий, следующий (в рамках следующего решения)
    Удаление с сохранением порядка
*/
int F20_val(std::vector<int> A, int n);
int F20_ref(std::vector<int>& A, int& n);
int F20_pointer(std::vector<int>* A, int* n);

/*
Функция 29:
Функция предназначена для нахождения наибольшего общего делителя для
элементов массива. Предположим, что будет логично инициализировать v значением
наибольшего элемента массива.

Стандартные решения:
    Переменная - максимум(ведь ищем максимальное значение) - счётчик(ведь
уменьшаем его на единицу с каждой реитерацией)
    Свойство всеобщности (алгоритмы из
cprog 2.4 модифицированы под реитерацию)
    Неравномерное движение (сразу прыгаем в
начало если первый найденный не соответствует условию)
*/
int F29_val(std::vector<int> A, int n);
int F29_ref(std::vector<int>& A, int& n);
int F29_pointer(std::vector<int>* A, int* n);

/*
Функция 32:
Функция предназначена для нахождения индекса элемента с наибольшим
количеством вхождений в массив И/или количества вхождений этого элемента.

Стандартные решения:
    Переменная - счётчик
    Переменная - максимум
    Вложенные циклы
*/
int F32_val(std::vector<int> c, int n);
int F32_ref(std::vector<int>& c, int& n);
int F32_pointer(std::vector<int>* c, int* n);

/*
Функция 50:
Функция предназначена для подсчёта чередований -,+ в рамках первых 10
элементов массива. В случае, если массив состоит менее, чем из 10 элементов,
функция вызовет исключение с кодом ошибки 11 (SEGFAULT). Функционально -
абсолютно идентична F56.

Стандартные решения:
    Переменная - счётчик
    Переменная - признак
    Предыдущий, текущий, следующий (в варианте с флаговой переменной, но логика
в целом та же)
*/
int F50_val(std::vector<int> A);
int F50_ref(std::vector<int>& A);
int F50_pointer(std::vector<int>* A);

/*
Функция 56:
Инициализируем i,s, движемся по массиву A от 1 до 9 включительно.
Если среди элементов встречено чередование -,+ (как и в прошлой функции),
увеличиваем счётчик на 1. for (i=1,s=0; i<10; i++) if (A[i]>0 && A[i-1]<0) s++;

Итог: функция предназначена для подсчёта чередований -,+ в рамках первых 10
элементов массива. В случае, если массив состоит менее, чем из 10 элементов,
функция вызовет исключение с кодом ошибки 11 (SEGFAULT). Функционально -
абсолютно идентична F50.

Стандартные решения:
    Переменная - счётчик
    Предыдущий, текущий, следующий
*/
int F56_val(std::vector<int> A);
int F56_ref(std::vector<int>& A);
int F56_pointer(std::vector<int>* A);
}
#endif