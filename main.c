#include <locale.h>
#include <stdio.h>
#include <limits.h>

//Вынесем в #define для удобства, и чтобы не засорять main
#define GREETINGS_STRING \
"Программа получает на вход два целых числа,\n\
и выполняет поиск такого числа,\n\
чтобы при сложении каждого из входных чисел с найденным,\n\
получался точный квадрат.\n"

#define EXIT_STRING \
"Захотите выйти? Нет ничего проще!\n\
Ctrl+C в любой момент исполнения решит вашу проблему!\n"

//Функция для определения, является ли число точным квадратом.
int is_square(long long int value) {
    /*
    Проверим, не подкинули ли нам
    отрицательный квадрат
    */
    if (value < 0) {
        return 0;
    }
    /*
    Применим математическую хитрость про то,
    что квадрат натурального числа всегда можно представить как сумму первых n нечётных чисел
    */
    long long int odd = 1;
    //Спокойно меняем value, ведь это лишь копия оригинального значения.
    while(value > 0) {
        value -= odd;
        odd += 2;
    }
    /*
    Если в ходе наших вычитаний мы получили 0 -
    значит, сумма нечётных оказалась равна числу, и это точный квадрат.
    */
    return value == 0;
}

int main(void) {
    setlocale(LC_ALL, "Russian");
    /*
    Почему long long int?
    Чтобы нам совершенно точно хватило памяти
    */
    long long int numbers[2] = {};
    int numbers_entered = 0;
    
    printf(GREETINGS_STRING);
    printf(EXIT_STRING);
    printf("Введите два целых числа:\n");
    while (numbers_entered < 2) {
        //Входной буфер того же размера, что и буфер stdin, чтобы ничего не потерять
        char inbuffer[BUFSIZ] = {};
        //Получаем из потока stdin весь буфер
        fgets(inbuffer, sizeof(inbuffer), stdin);
        long long int num_buffer[2] = {};
        /*
        1) Считываем из буфера char числа в буфер long long int
        2) sscanf возвращает количество успешно считанных значений, запоминаем их в consumed.
        */
        int consumed = sscanf(inbuffer, "%lli%lli", &num_buffer[0], &num_buffer[1]);
        /*
        Пробегаемся по полученным значениям, и добавляем их
        в итоговый массив, если в нём есть свободное место
        */
        for (int i = 0; i < consumed && numbers_entered < 2; i++) {
            numbers[numbers_entered++] = num_buffer[i];
        }
    }
    printf("Введены числа: %lli, %lli\n", numbers[0], numbers[1]);
    /*
    Видя подобный ввод, появляется логичный вопрос:
    Зачем всё это?
    Можно ведь просто получать значения сразу
    scanf("%lli%lli", &numbers[0], &numbers[1]) решит проблему!1!1!

    Нет, не решит. Если мы вдруг получим в stdin
    невалидное значение, к примеру, букву,
    то scanf просто оставит её в потоке, после чего,
    видя что поток не пустой, начнёт считывать и отбрасывать
    эту букву раз за разом.
    fgets же скушает весь поток и не подавится.
    */
    
    long long int solution = 0;
    int solved = 0;
    if (numbers[0] == numbers[1]) {
        solved = 2;
    } else if (is_square(numbers[0]) && is_square(numbers[1])) {
        solved = 1;
    } else { 
        /*
        Немножко (множко) подумав, мы понимаем, что решение задачки выглядит как:
        numbers[0] + test_value = a^2;
        numbers[1] + test_value = b^2;
        a, b, test_value - должны существовать в целых числах, numbers[] существуют и так.

        Попробуем вычесть одно из другого, получим:
        numbers[1] - numbers[0] = b^2 - a^2 = (b-a)(b+a)
        Работаем с целыми числами, значит, можем пользоваться суммой/разностью чётных/нечётных.
        Итак, представим:
        b % 2 == 1, a % 2 == 0
        b-a % 2 = 1
        b+a % 2 = 1

        b % 2 == 1, a % 2 == 1
        b-a % 2 = 0
        b+a % 2 = 0

        b % 2 == 0, a % 2 == 0
        b-a % 2 = 0
        b+a % 2 = 0

        Получается, что numbers[1] - numbers[0] всегда будет == нечёт*нечёт или чёт*чёт
        Это мы уже можем проверить
        Если говорим о чёт*чёт - значит каждое число кратно двум, значит, результат кратен 4
        Если говорим о нечёт*нечёт - значит, результат кратен двум никогда не будет.

        Учитывая, что всё это мы выяснили, исходя из предположения, что test_value существует,
        рискну сказать, что верно и обратное.
        */
        if ((numbers[1] - numbers[0]) % 4 == 0 || (numbers[1] - numbers[0]) % 2 != 0) {
            /*
            Определим меньшее и большее из введённых значений
            запишем меньшее в numbers[0], большее в numbers[1]
            */
            if (numbers[0] > numbers[1]) {
                long long int buff = numbers[0];
                numbers[0] = numbers[1];
                numbers[1] = buff;
            }
            /*
            Что нам даёт такое присвоение?
            Мы знаем, что квадрат находится в пределах [0;+inf)
            А значит, первый кандидат на прибавление к числам - тот, который сведёт
            наименьшее из них в 0.
            */
            solution = numbers[0]*-1;
            for ( ; (!is_square(numbers[0]+solution) || !is_square(numbers[1]+solution)) 
                && numbers[1]+solution < LLONG_MAX; solution++);
            solved = numbers[1]+solution == LLONG_MAX ? 0 : 1;
        }
    }

    switch (solved) {
        case 0:
            printf("К сожалению, мы не нашли решения.\n");
            break;
        case 1:
            printf("Число, удовлетворяющее условию: %lli\n", solution);
            break;
        case 2:
            printf("Любой квадрат будет решением для данных параметров.\n");
            break;    
    }   

    return 0;
}