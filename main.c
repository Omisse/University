#include <locale.h>
#include <stdio.h>

#include "parsing.h"

#define GREETINGS_STRING \
"Программа выполняет сортировку массива способом демона Максвелла.\n\
На вход получаем число элементов массива и один из вариантов или их комбинацию:\n\
1) Десятичные числа в количестве меньшем или равном введённому числу элементов\n\
2) Символ '*' для автоматической генерации массива.\n"

//Все индексы и длины будут храниться в ull, чтобы мы могли больше вместить.
//Прозвище этому типу назначаем просто для удобства.
typedef unsigned long long ull;

/*
max_ и min_value абсолютно идентичны по своей структуре:
0) Они обе небезопасны, и им обоим индифферентно, что в них суют -
каждая триггернёт сегфолт при неправильном использовании
1) На входе получаем некоторый массив, индексы начала и конца и указатель,
чтобы не только выдать значение, но и его адрес в памяти.
2) Первый элемент служит инициализатором для наших внутренних переменных
3) Все остальные до последнего включительно проверяются в рамках, собственно,
нахождения максимума/минимума.
*/
double max_value(double* const values, ull start, ull end, double** out) {
    double value = values[start];
    *out = &(values[start]);
    for (ull i = start+1; i <= end; i++) {
        if (values[i] > value) {
            value = values[i];
            *out = &(values[i]);
        }
    }
    return value;
}

double min_value(double* const values, ull start, ull end, double** out) {
    double value = values[start];
    *out = &(values[start]);
    for (ull i = start+1; i <= end; i++) {
        if (values[i] < value) {
            value = values[i];
            *out = &(values[i]);
        }
    }
    return value;
}

//Меняем значения по двум указателям, что тут скажешь.
void swap_values(double* v1, double* v2) {
    double buffer = *v1;
    *v1 = *v2;
    *v2 = buffer;
}

/*
Алгоритм сортировки на деле практически не отличается от qsort,
разве что вместо опоры на конкретное значение мы утверждаем, что в серединке должно быть, условно,
среднее, относительно которого и будут меняться элементы.

Сортировка рекурсивная, идея следующая:
Ставим условный барьер в серединке нашей области работы (массив делится на две половинки, потом ещё на две и т.д.)
Далее "ждём"
Если исходить из идеи демона Максвелла -
в это время все наиболее энергонасыщенные частицы перетекают в одну область,
наименее энергонасыщенные - в другую.

Мы же точно знаем, что число элементов в массиве не изменится,
поэтому с чистой душой игнорируем броуновские движения и сразу меняем лучших кандидатов между собой
(В каком-то смысле, энергонасыщенная частица движется куда активнее, так что это даже логично)

Как только мы достигли баланса в разрезе наших двух половинок, радостно делим их ещё раз,
и так пока каждая частичка не будет окружена этими "барьерами"

В результате кучи перемещений получаем отсортированный массив.
*/
ull demon_sort(double* const values, ull low, ull high) {
    //Определяем "серединку" нашего массива
    //Для чётных массивов всё понятно, для нечётных - нижняя часть будет на единичку больше
    ull low_end = (high+low)/2;
    //Мы не хотим, чтобы при дроблении массива в обоих частях оказался один и тот же элемент.
    ull high_start = low_end+1;
    double *v1, *v2;
    ull actions = 2;
    //Расшифровываем, что происходит:
    /*
    Пока _наименьшее_ из значений правой части массива меньше, чем наибольшее из левой части - 
    меняем их местами.
    */
    while (min_value(values, high_start, high, &v1) < max_value(values, low, low_end, &v2)) {
        swap_values(v1, v2);
        actions += 3*(high-low+4);
    }
    //3*(end-start+1) - трудоёмкость min_, max_value в худшем случае. == 3N
    //Внутри цикла добавим три действия для замены переменной.
    actions += 3*(high-low+1);
    //Тут у нас получается ситуация, что в левой половинке каждое из чисел меньше, чем каждое из правой.
    /*
    Чтобы не выдумывать чудес, рекурсивно вызываем этот же алгоритм до тех пор,
    пока область работы не станет меньше двух элементов.
    */
    if (high > high_start) {
        actions += demon_sort(values, high_start, high);
    }
    if (low_end > low) {
        actions += demon_sort(values, low, low_end);
    }
    actions += 2;
    return actions;
}

//Форматированный вывод массива, используем дважды, так что почему бы и не вынести
void print_array(const double* const values, ull amount) {
    printf("{ ");
    for (ull i = 0; i < amount; i++) {
        if (i) {
            printf(", ");
        }
        printf("%0.3lf", values[i]);
    }
    printf("}\n");
}

int main(void) {
    setlocale(LC_ALL, "Russian");
    //Здороваемся, объясняем что происходит
    printf(GREETINGS_STRING);
    ull amount;
    double* values;
    //Если при обработке ввода что-то пошло не так - просто не будем пытаться.
    if (process_input(&amount, &values)) {
        printf("Входной массив [%llu]: ", amount);
        print_array(values, amount);
        //Вызов сортировки.
        /*
        amount-1 потому, что это раньше мы работали с 
        "количеством элементов", и в циклах говорили что i строго меньше его.
        Теперь мы работаем с индексами, помня, что < стало <=,
        а само число на единичку меньше.
        */
        ull actions = demon_sort(values,0, amount-1);
        printf("Итоговый массив [%llu]: ", amount);
        print_array(values, amount);
        printf("Трудоёмкость: %llu действий для %llu значений.\n", actions, amount);
        /*
        В комментариях к parsing.c есть строчка про это, но напомним:
        наш массив значений выделяется в куче, это динамическая память,
        и чистить её мы должны сами.
        К слову, именно поэтому мы не чистим её в else{} - она выделялась
        во время обработки ввода, и если обработка поймала ошибку - значит и памяти выделено не было.
        Впрочем, последнее утверждение уже зависит от реализаций, но у меня - вот так.
        */
        free(values);
    } else {
        printf("Данные некорректны/Ошибка выделения памяти.\n");
    }
    return 0;
}

/*
TESTING CODE

int main() {
    setlocale(LC_ALL, "Russian");
    for (int loop = 0; loop < 50; loop++) {
        printf("ITERATION: %d\n", loop);
        ull amount = rand()%15+1;
        double* values = malloc(amount*sizeof(double));
        if (values) {
            ull consumed = 0;
            for ( ; consumed < amount; consumed++) {
                double r1 = rand() % 8942;
                double r2 = rand() % 113;
                values[consumed] = r1;
                if (r2 != 0) {
                    values[consumed] /= r2;
                }
                values[consumed] *= rand() % 2 ? -1.0f : 1.0f;
            }
            printf("Входной массив [%llu]: {", amount);
            for (ull i = 0; i < amount; i++) {
                if (i) {
                    printf(", ");
                }
                printf("%0.3lf", values[i]);
            }
            printf("}\n");
            demon_sort(values,0, amount-1);
            printf("Итоговый массив [%llu]:\t{", amount);
            for (ull i = 0; i < amount; i++) {
                if (i) {
                    printf(", ");
                }
                printf("%0.3lf", values[i]);
            }
            printf("}\n");
            free(values);
        }
    }
    
    return 0;
}
*/