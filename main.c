#include <ctype.h>
#include <locale.h>
#include <stdio.h>
#include <string.h>

#define BUFSIZ_SHORT 255

#define NUMERIC_CHARS "0123456789abcdefABCDEF"
#define GREETINGS_STRING \
"Программа получает на вход два целых числа (0-F).\n\
Программа поддерживает ввод во всех системах счисления \
от двоичной до шестнадцатеричной.\n\
Результатом работы программы является вывод всех найденных конверсий\n\
\"ввод->число в произвольной базе->число в произвольной базе->вывод\",\n\
при которых строковое представление вывода будет одинаковым для двух введённых чисел.\n"

//Проверка, является ли символ шестнадцатеричной цифрой.
int isdigit_hex(char ch) {
    //strchr ищет элемент в указанной строке, если найдёт - вернёт указатель, иначе (void*) 0.
    return strchr(NUMERIC_CHARS, ch) != NULL;
}

int get_user_input(char* out1, char* out2) {
    //Чтобы не копировать код, соберём наши указатели в массив.
    char* out_ptrs[2] = {out1, out2};
    char ch = 'g';
    //Пробежимся по массиву
    for (int i = 0; i < 2 && ch != EOF; i++) {
        //Пропустим мусор
        while (!isdigit_hex(ch) && ch != EOF) {
            ch = fgetc(stdin);
        }
        char* inptr = out_ptrs[i];
        //Пока получаем из stdin шестнадцатеричные цифры - пишем их в out1, сдвигая позицию.
        while (isdigit_hex(ch)) {
            *(inptr++) = tolower(ch); //приведём A...F к a...f сразу, чтобы непосредственно алгоритм не тратил время.
            ch = fgetc(stdin);
        }
        *inptr = 0;
    }
    //Если поймали EOF при вводе из файла - значит, в этом файле чего-то не хватало.
    return ch != EOF;
}

int get_min_base(const char* in) {
    //Здесь и далее уже работаем только с a...f
    const char possible[] = "0123456789abcdef";
    const char* ptr = in;
    int out = 0;
    //Пока не конец строки ('\0' == 0 == false)
    while (*ptr) {
        /*
        Для каждого(ptr++) символа из строки на входе
        находим его позицию в нашем массиве возможных
        */
        char* poss_ptr = strchr(possible, *ptr);
        /*
        Массив уже в нужном порядке, поэтому достаточно просто
        Вычесть указатель на начало из найденного, чтобы получить наибольшее число базы
        Да, система счисления будет на единичку больше.
        */
        int base = poss_ptr-possible;
        //В рамках первичной конверсии, нас интересует именно максимальное значение.
        if (base > out) {
            out = base;
        }
        ptr++;
    }
    /*
    Да, мы можем получить тут базу "1", но
    в реалиях нашего алгоритма нас это абсолютно полностью устраивает,
    ведь это лишь значит, что либо оба числа будут 0,
    либо они никогда не станут равны.
    */
    return out+1;
}

//Конвертируем символ в десятичное число(да, написано "в_цифру")
int to_digit(char ch) {
    int out = 0;
    //символы 0-9 идут в ряд, аналогично для a-f поэтому мы можем так сделать
    if (ch >= '0' && ch <= '9') {
        //Можно бы и -'0' писать, но так понятнее, что и зачем.
        out = ch-48;
    } else if (ch >= 'a' && ch <= 'f') {
        //+10 потому, что вычитание уронит нас в [0,5]
        out = ch-97+10;
    }
    return out;
}

//Перевод строки в произвольной базе в десятичное число.
int strtoi_base(const char* str, int base) {
    int out = 0;
    const char* strptr = str;
    //Проматываем до конца строки
    while (*(strptr++));
    //Вычитаем 2: -1 за лишний ++ и -1 за \0, который тоже нам не нужен.
    strptr-=2;
    int power = 0;
    /*
    Идём с конца в начало.
    Можно и без всего выше идти из начала в конец,
    но этот способ показан на обратной конверсии,
    да и длину знать всё равно нужно для степеней.
    */
    while (strptr >= str) {
        //Получаем просто число
        int buff = to_digit(*strptr);
        for (int i = 0; i < power; i++) {
            /*
            Домножаем его на основание, в зависимости от положения в строке
            первый с конца умножится 0 раз,
            второй 1, третий 2 и так далее.
            */
            buff*=base;
        }
        //Добавляем к итоговому числу результат
        out+=buff;
        //Увеличили степень для следующего раза.
        power++;
        //Сдвинулись ближе к началу
        strptr--;
    }
    return out;
}

char to_char(int num) {
    char out = 0;
    //Аналогично to_digit() с той лишь разницей, что теперь прибавляем, а не отнимаем
    if (num >= 0 && num <= 9) {
        out = 48+num;
    } else if (num >= 10 && num <= 16) {
        out = 97+(num-10);
    }
    return out;
}

/*
Конверсия из десятичного числа в строку произвольной базы.
*/
void strfromi_base(int value, int base, char* out) {
    char* endptr = out;
    /*
    Если число == 0, то просто поставим '0', остальное алгоритм доделает позже
    Сама проверка нужна потому, что иначе в цикл мы не попадём, и поставить
    нолик можно будет только нам.
    */
    if (!value) {
        *(endptr++) = '0';
    }
    /*
    Далее, пока от числа ничего не останется, делим его на основание,
    остаток пишем в строку, остальное - до следующей итерации.
    */
    while (value) {
        int rem = value % base;
        value /= base;
        *(endptr++) = to_char(rem);
    }
    /*
    К этому моменту endptr будет всегда указывать на элемент после последнего значащего
    Обозначим конец строки и вернёмся в область работы
    */
    *endptr = 0;
    endptr--;
    /*
    Мне почему-то нравится как это работает
    Пока указатель на правую сторону больше указателя на левую,
    мы меняем местами символы в нашей строке
    Если символов чётное число - замечательно, поменяли последний, стали меньше и разошлись
    Если нечётное - встретились в серединке, а ничего и менять не надо.
    */
    while (endptr > out) {
        char buff = *out;
        *out = *endptr;
        *endptr = buff;
        endptr--;
        out++;
    }
}

int main() {
    setlocale(LC_ALL, "Russian");
    printf(GREETINGS_STRING);
    printf("Введите два числа, возможные символы: %s\n", NUMERIC_CHARS);
    //Создадим два массива под наши строки с числами.
    char in1[BUFSIZ_SHORT] = "";
    char in2[BUFSIZ_SHORT] = "";
    //Тут будет 0 только если вводили из файла и файл закончился раньше чем всё получилось.
    if (get_user_input(in1, in2)) {
        //Начинается страх и ужас, итак:
        //В системе счисления от минимально возможной для введённых символов 1 числа:
        for (int in_base1 = get_min_base(in1); in_base1 <= 16; in_base1++) {
            //Узнаём как выглядит число 1 в десятичной системе.
            int in_val1 = strtoi_base(in1, in_base1);
            //В системе счисления от минимально возможной для введённых символов 2 числа:
            for (int in_base2 = get_min_base(in2); in_base2 <= 16; in_base2++) {
                //Узнаём как выглядит число 2 в десятичной системе.
                int in_val2 = strtoi_base(in2, in_base2);
                //В системах счисления от 2 до 16,
                for (int out_base1 = 2; out_base1 <= 16; out_base1++) {
                    //Создаём буфер под первое число
                    char out_val1[BUFSIZ_SHORT] = "";
                    //Переводим первое число из десятичной в 2-16
                    strfromi_base(in_val1, out_base1, out_val1);
                    //В системах счисления от 2 до 16,
                    for (int out_base2 = 2; out_base2 <= 16; out_base2++) {
                        //Создаём буфер под второе число
                        char out_val2[BUFSIZ_SHORT] = "";
                        //Переводим второе число из десятичной в 2-16
                        strfromi_base(in_val2, out_base2, out_val2);
                        //Если по результатам сравнения итоговых строк вышло, что они одинаковы
                        if (strcmp(out_val1, out_val2)==0) {
                            /*
                            Выводим:
                            Ввод1, Ввод2 ->
                            <восприняли в>(системе 1.1)(системе 2.1) ->
                            <тогда десятичное> число1, число2 ->
                            <конвертируется в> (систему 1.2)(систему 2.2) ->
                            <и на выходе> Вывод1, Вывод2.
                            */
                            printf("%s, %s -> (%d)(%d) -> %d, %d -> (%d)(%d) -> %s, %s\n",
                                in1, in2,
                                in_base1, in_base2,
                                in_val1, in_val2,
                                out_base1, out_base2,
                                out_val1, out_val2);
                        }
                    }
                }
            }
        }
    } else {
        printf("Ошибка, проверьте введённые числа.\n");
    }
    //Даже при ошибке ввода, де-юре программа отработала нормально, с памятью проблем не возникло, значит всё равно нолик.
    return 0;
}