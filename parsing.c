#include "parsing.h"

#define AUTO_CHAR '*'

int flush_to_num_or_spec(char* ch) {
    int sign = 0;
    while (!isdigit(*ch) && *ch != AUTO_CHAR && *ch != EOF) {
        sign = *ch == '-';
        *ch = fgetc(stdin);
    }
    //вернём 1 если увидели отрицательное число
    return sign && isdigit(*ch);
}

/*
Итак, как же работает наш чудо-парсер?
*/
int process_input(unsigned long long* amount, double** values) {
    /*
    Базово отвалидируем то, что в нас засунули,
    чтобы не поймать сегфолт по входным == NULL
    Нужно это только потому, что с поинтерами работаем.
    */
    if (!amount || !values) {
        return 0;
    }
    *amount = 0;
    *values = 0;
    //Создаём статический буфер чаров, будем переиспользовать.
    char in_buffer[BUFSIZ] = {};
    int buffer_pos = 0;
    
    //Инициализируем "грязный" чар.
    char ch = 'a';
    //Пропускаем весь ввод, пока не встретим число
    while (!isdigit(ch) && ch != EOF) {
        ch = fgetc(stdin);
    }
    //Копируем всё число в наш буфер
    while (isdigit(ch) && ch != EOF) {
        in_buffer[buffer_pos++] = ch;
        ch = fgetc(stdin);
    }
    //После числа ставим 0 ('\0'), гарантируя, что буфер - валидная строка.
    in_buffer[buffer_pos] = 0;

    /*
    Конвертируем буфер в целое беззнаковое
    У этого чуда может произойти переполнение, но тут уже увы.
    В любом случае, дальше по ходу работы увидим значение.
    */
    /*
        При вводе из файла, можно поймать прикол
        если в файле нет цифр или вообще ничего нет
        in_buffer окажется пустым
        strtoull выдаст нам "что-то"
        а так, оставляем 0 и радуемся.
    */
    if (buffer_pos) {
        *amount = strtoull(in_buffer,NULL, 10);
    }
    
    /*
    Если юзер вписал 0 - ну, тут медицина бессильна
    Вообще можно и return сразу писать,
    но хорошей практикой считается
    один вход и один выход из функции, не считая валидации входных.
    */
    if (*amount) {
        /*
        ALARM! ALARM! ALARM!
        Выделяем память под наш массив значений
        */
        *values = malloc(sizeof(double)*(*amount));
        /*
        Если выделили успешно, *values будет != 0
        В противном случае malloc вернёт нам NULL,
        который по сути (void*) 0, и мы это проверяем,
        чтобы случайно не поймать сегфолт.
        */
        if (*values) {
            unsigned long long consumed = 0;            
            while (consumed < *amount && ch != AUTO_CHAR && ch != EOF) {
                //юзверь ввёл число, не мусор, не попросил помочь.
                //чистим буфер, чтобы чисто было.
                buffer_pos = 0;
                memset(in_buffer, 0,BUFSIZ);
                /*
                Пропускаем весь невалидный мусор
                до тех пор, пока юзверь не введёт что ему сказали.
                */
                /*
                Если мы всё же нашли число, а не ударились в EOF || AUTO_CHAR
                То оставим знак на будущее
                */
                int negative = flush_to_num_or_spec(&ch);
                //Копируем встреченное число в буфер
                while ((isdigit(ch) || ch == '.') && ch != EOF) {
                    in_buffer[buffer_pos++] = ch;
                    ch = fgetc(stdin);
                }               
                /*
                Тут можно было бы проверить, что в буфере что-нибудь есть,
                но на деле, раз мы вошли сюда по циферке,
                значит будет как минимум она.
                */
                if (ch != AUTO_CHAR && ch != EOF) {
                    (*values)[consumed++] = strtod(in_buffer, NULL);
                    if (negative) {
                        (*values)[consumed-1] *= -1;
                    }
                }
            }
            //Теперь на тему генерации
            //srand() обновит наш хэш для генерации
            //time() суём туда чтобы хэш был всегда разным
            srand((unsigned int) time(0));
            /*
            До тех пор, пока мы не забьём массив значениями - суём туда произвольные числа
            Да, rand() производит только инты, поэтому мы делим ранд на ранд,
            конвертированные в (double), получая
            double в рамках rvalue, и даже с дробными числами!

            Если пользователь сдался на полпути - его ввод останется на своих местах
            Если говорить о файле, тут интереснее
            В файле символ поражения - не только *, но и EOF, и если
            мы этот самый EOF поймали, логика нисколько не меняется. 
            */
            for ( ; consumed < *amount; consumed++) {
                //Генерация собственно числа
                double r1 = rand() % 8942;
                double r2 = rand() % 113;
                (*values)[consumed] = r1;
                if (r2 != 0) {
                    (*values)[consumed] /= r2;
                }
                //Генерация знака этому чудесному числу
                (*values)[consumed] *= rand() % 2 ? -1.0f : 1.0f;
            }
        }
    }    
    return *values != NULL;
}